import pickle
import numpy as np
import matplotlib.pyplot as plt
from scipy.linalg import solve_lyapunov
from LLE_Solver import *


def getValidIndices(I,J,N_lle):
    valid1 = []
    valid2 = []
    valid3 = []
    valid1_python = []
    valid2_python = []
    valid3_python = []
    for C in range(-N_lle,N_lle+1):
        K1 = I+J-C
        K2 = I+C-J
        K3 = J+C-I
        if K1 in range(-N_lle,N_lle+1):
            valid1.append([C,K1])
            valid1_python.append([C+N_lle, K1+N_lle])
        if K2 in range(-N_lle,N_lle+1):
            valid2.append([C,K2])
            valid2_python.append([C+N_lle, K2+N_lle])
        if K3 in range(-N_lle,N_lle+1):
            valid2.append([C,K3])
            valid2_python.append([C+N_lle, K3+N_lle])
    return valid1, valid2, valid3, valid1_python, valid2_python, valid3_python

class QuantumFlux:
    def __init__(self,
                 input_filename = 'SingleSoliton.pkl',
                 input_dir = 'data/LLE/',
                 output_dir = 'data/Quantum Flux/'):
        """
        This object gives a solver for the entanglement matrix for the modes
        of a dissipative Kerr soliton, as described in "Multi-color continuous
        -variable quantum entanglement in dissipative Kerr solitons", Li (2021)
        [This paper will be hereafter referred to as Ref_A]
        
        This requires a previously calculated LLE solution - from the 
        LLE_Solver class in LLE_Solver.py - which has been saved to a .pkl 
        file. This filename (and directory) are the only required inputs.
        
        Use: call x = QuantumFlux(filename, filedir), then x.calculateParams()
        or any of the sub-methods of x.calculateParams() as required

        Parameters
        ----------
        input_filename : TYPE, optional
            Filename for the saved LLE_Solver object. The default is
            'SingleSoliton.pkl'.
        input_dir : TYPE, optional
            Directory of input_dir. The default is 'data/LLE/'.
        output_dir : TYPE, optional
            Directory for saving this object to. The default is 
            'data/Quantum Flux/'.

        Returns
        -------
        QuantumFlux object.
        
        **********************************************************************
        To-Do ****************************************************************
        =====
        - calculate g0 from the imported LLE_Solver object (currently =1)
        - Confirm indexing inside self.makeCouplingMatrix()
        - Confirm elements of D matrix in self.makeDiffMatrix()
        - Confirm elements of M matrix in self.makeCouplingMatrix()
        - Confirm sign of D matrix in self.makeCorrelationMatrix()
        - Confirm indexing inside self.makeLogarithmicNegativityMatrix()
        **********************************************************************
        """
        # Load associated LLE solver object
        self.input_filename = input_filename
        self.input_dir = input_dir
        self.LLE_Soln = load_previous(self.input_dir+self.input_filename)
        self.reduce_LLESoln() # Remove unwanted initial mode
        self.g0 = self.LLE_Soln.dw0 # Need to update this!
        # Set directory to save object info to
        self.output_dir = output_dir
        
    def reduce_LLESoln(self):
        """
        The (current) LLE soln object has an asymmetric number of modes, i.e.
        for mode number N it has the modes ell=[-2,-1,0,1] with no +2. The 
        simplest way to deal with this is to remove the first row,column of 
        all the important parts.

        Returns
        -------
        Updated self.LLE_Soln object with symmetric modes.

        """
        updatableParms = ['theta','ell','ell2','psi','psi_f'] # List to update
        for param in updatableParms: # Update all objects in list
            self.LLE_Soln.__dict__[param] = self.LLE_Soln.__dict__[param][1:]
            
        self.LLE_Soln.N -= 1
        
    def calculateParams(self):
        """
        This method runs through the solver in accordence with "Multi-color
        continuous-variable quantum entanglement in dissipative Kerr solitons",
        Li (2021). Each step is made up of a sub-method for a) ease of reading
        b) allowing the user to call individual 
        Returns
        -------
        Updated QuantumFlux object, with all parameters calculated.

        """
        self.N_lle = int(self.LLE_Soln.N/2) # Number of LLE modes calculated
        self.N = 4*self.N_lle + 2 # Number of quadratures to be calculated
        # NB) self.N = 4*self.N_lle because there are two lots of each mode 
        # (one above, one below the pump), each with two quadratures
        
        self.makeBetas() # Make the effective detuning vector, Beta
        self.makeDiffMatrix() # Make the diffusion matrix, D
        self.makeCouplingMatrix() # Make the matrix, M
        self.makeCorrelationMatrix() # Make the correlation matrix, V
        self.makeLogarithmicNegativityMatrix() # Make entanglement matrix, E
        plt.imshow(self.E)
        
    def makeBetas(self):
        """
        This (sub-)method makes the Beta vector of Eq. 3 given in the 
        paragraph just following the equation in Ref_A

        Returns
        -------
        Updated QuantumFlux object, with Beta parameter calculated..

        """
        deltaVec = self.LLE_Soln.ell2*self.LLE_Soln.beta + self.LLE_Soln.alpha
        self.Beta = -1.0j*deltaVec + self.LLE_Soln.dw0
        
    def makeDiffMatrix(self):
        """
        This (sub-)method makes the D matrix of Eq. 4 given in the 
        paragraph just following the equation in Ref_A

        Returns
        -------
        Updated QuantumFlux object, with Beta parameter calculated.
        
        **********************************************************************
        To-Do ****************************************************************
        =====
        - Confirm matrix elements. They're currently just set uniformly to the
        linewidth of the cavity (each mode assumed to have the same losses),
        but the exact value may be different to that calculated here
        **********************************************************************

        """
        self.D = np.eye(self.N) * np.sqrt(2*self.LLE_Soln.dw0) # Noise matrix
        
    def makeCouplingMatrix_orig(self):
        """
        This (sub-)method makes the M matrix of Eq. 4 of Ref_A, with a method
        derived from Eq. 3 of Ref_A. This method is given in "Continuous 
        Variable Entanglement.ipynb" under Quantum Fluctuations.

        Returns
        -------
        Updated QuantumFlux object, with the M matrix parameter calculated.
        
        **********************************************************************
        To-Do ****************************************************************
        =====
        - Confirm method derived from Eq. 3, Ref_A. Very fiddly and likely to
        have either errors in the method itself, or typos in the subsequent 
        code
        - Check indexing. I'm currently using a (b) as the row (column) 
        numbers, which each refer to the mode number i~a/2 (j~b/2) as there are
        two rows (columns) for each mode due to there being two quardratures
        for each. The int(a/2)-1 etc. might not be correct! Also check that we 
        correctly run through the correct set of indices - might try this with
        small matrices manually...!
        **********************************************************************

        """
        self.M = np.zeros((self.N,self.N),dtype=float)
        self.alpha = self.LLE_Soln.psi_f
        Quads = ['X','Y']
        
        for i in range(self.N):
            print('\rRunning simulation: {:.2f}%'.format(100*i/self.N),
                  end="")
            for j in range(self.N):
                I = int(i/2) - self.N_lle # LLE mode number row
                J = int(j/2) - self.N_lle # LLE mode number column
                Quad_row = Quads[i%2] # Quadrature row (X or Y)
                Quad_col = Quads[j%2] # Quadrature col (X or Y)
                a = i + 1 # Index a from ipynb 
                b = j + 1 # Index b from ipynb 
                m_ab = 0
                if a%2 != 0: # a is odd
                    if b == a:
                        m_ab  = np.real(self.Beta[I+self.N_lle])
                    elif b == a+1:
                        m_ab = -np.imag(self.Beta[I+self.N_lle])
                    else:
                        v1, v2, v3, v1p, v2p, v3p = getValidIndices(I,
                                                                   J,
                                                                   self.N_lle)
                        for valid1 in v1p:
                            C, D  = valid1
                            m_ab += self.g0*(self.alpha[C]*self.alpha[D])
                        for valid2 in v2p:
                            C, D  = valid2
                            m_ab += 2*self.g0*(self.alpha[C]*
                                               np.conj(self.alpha[D]))
                        if b%2 == 0:
                            m_ab = np.imag(m_ab)
                        else:
                            m_ab = np.real(m_ab)
                else: # a is even
                    if b == a:
                        m_ab = -np.imag(self.Beta[I+self.N_lle])
                    elif b == a-1:
                        m_ab  = np.real(self.Beta[I+self.N_lle])
                    else:
                        v1, v2, v3, v1p, v2p, v3p = getValidIndices(I,
                                                                   J,
                                                                   self.N_lle)
                        for valid1 in v1p:
                            C, D  = valid1
                            m_ab += self.g0*(self.alpha[C]*self.alpha[D])
                        for valid2 in v2p:
                            C, D  = valid2
                            m_ab -= 2*self.g0*(self.alpha[C]*
                                               np.conj(self.alpha[D]))
                        if b%2 == 0:
                            m_ab = np.real(-m_ab)
                        else:
                            m_ab = np.imag(m_ab)
                        
                self.M[i][j] = m_ab
                
        # Save this object after a long calculation to avoid needless 
        # repetition
        self.save_self()
        
    def makeCouplingMatrix(self):
        """
        This (sub-)method makes the M matrix of Eq. 4 of Ref_A, with a method
        derived from Eq. 3 of Ref_A. This method is given in "Continuous 
        Variable Entanglement.ipynb" under Quantum Fluctuations.

        Returns
        -------
        Updated QuantumFlux object, with the M matrix parameter calculated.
        
        **********************************************************************
        To-Do ****************************************************************
        =====
        - Confirm method derived from Eq. 3, Ref_A. Very fiddly and likely to
        have either errors in the method itself, or typos in the subsequent 
        code
        - Check indexing. I'm currently using a (b) as the row (column) 
        numbers, which each refer to the mode number i~a/2 (j~b/2) as there are
        two rows (columns) for each mode due to there being two quardratures
        for each. The int(a/2)-1 etc. might not be correct! Also check that we 
        correctly run through the correct set of indices - might try this with
        small matrices manually...!
        **********************************************************************

        """
        self.alpha = self.LLE_Soln.psi_f
        N = len(self.alpha)
        print(N)
        print(abs(self.alpha[int(N/2)-1:int(N/2)+2]))
        self.alpha[int(N/2)] = self.alpha[int(N/2)]*abs(self.alpha[int(N/2)])/abs(self.alpha[int(N/2)])
        A = np.zeros((N,N))
        B = np.zeros((N,N))
        C = np.zeros((N,N))
        D = np.zeros((N,N))
        for I in range(N):
            print('\rRunning simulation: {:.2f}%'.format(100*I/N),
                  end="")
            for J in range(N):
                if I == J:
                    A[I][J] += np.real(self.Beta[I])
                    B[I][J] -= np.imag(self.Beta[I])
                    C[I][J] += np.imag(self.Beta[I])
                    D[I][J] += np.real(self.Beta[I])
                sum1 = 0
                sum2 = 0
                
                for c in range(N):
                    try:
                        sum1 += self.alpha[c]*self.alpha[I+J-c]
                    except IndexError:
                        _ = True
                    try:
                        sum2 += self.alpha[c]*self.alpha[c+I-J]
                    except IndexError:
                        _ = True
                A[I][J] += self.g0*(np.imag(sum1) - 2*np.imag(sum2))
                B[I][J] -= self.g0*(np.real(sum1) - 2*np.real(sum2))
                C[I][J] -= self.g0*(np.real(sum1) + 2*np.real(sum2))
                D[I][J] -= self.g0*(np.imag(sum1) - 2*np.imag(sum2))
                        
        self.A_ = A      
        self.B_ = B      
        self.C_ = C      
        self.D_ = D
                    
        self.M = ( np.kron(A,np.array([[1,0],[0,0]]))
                  +np.kron(B,np.array([[0,1],[0,0]]))
                  +np.kron(C,np.array([[0,0],[1,0]]))
                  +np.kron(D,np.array([[0,0],[0,1]])))
        # Save this object after a long calculation to avoid needless 
        # repetition
        self.save_self()
    
    
    def makeCorrelationMatrix(self):
        """
        This (sub-)method solves Eq. 4 of Ref_A for the V matrix. This is an 
        example of the Lyapunov equation so it uses the scipy.linalg method 
        for the solution.

        Returns
        -------
        Updated QuantumFlux object, with the V matrix parameter calculated.
        
        **********************************************************************
        To-Do ****************************************************************
        =====
        - Confirm the sign of the D matrix for the scipy Lyapunov solver.
        **********************************************************************

        """
        self.V = solve_lyapunov(self.M, self.D)
        self.save_self()
        
    def makeLogarithmicNegativityMatrix(self):
        """
        This (sub-)method solves Eq. 5 of Ref_A for the E matrix. 

        Returns
        -------
        Updated QuantumFlux object, with the E matrix parameter calculated.
        
        **********************************************************************
        To-Do ****************************************************************
        =====
        - Confirm the indexing for the A, B, C (C_t) matrices
        **********************************************************************

        """
        self.E = np.zeros((self.N_lle,self.N_lle),dtype=float)
        for i in range(self.N_lle):
            for j in range(self.N_lle):
                ## Check indexing for the A, B, C submatrices etc!!
                A = self.V[2*i:2*i+2,2*i:2*i+2]
                B = self.V[2*j:2*j+2,2*j:2*j+2]
                C = self.V[2*i:2*i+2,2*j:2*j+2]
                C_t = self.V[2*j:2*j+2,2*i:2*i+2] # should be transpose of C!
                
                theta = (np.linalg.det(A) + np.linalg.det(B) 
                         - 2*np.linalg.det(C))
                V1 = np.concatenate((A,C),axis=1)
                V2 = np.concatenate((C_t,B),axis=1)
                V = np.concatenate((V1,V2),axis=0)
                eta = np.sqrt(theta - np.sqrt(theta**2 - 4*np.linalg.det(V)))
                self.E[i][j] = np.max([0,-np.log(eta*2**0.5)])
        self.save_self()
        
    def save_self(self, filename=None):
        """
        This method saves the object as a .pkl file to save progress from 
        calculations.

        Parameters
        ----------
        filename : TYPE, optional
            Filename for save. The default is None, which saves the file to
            the output directory and input filename specified when the object
            was initialised.

        Returns
        -------
        None.

        """
        if filename is None:
            filename = self.output_dir + self.input_filename
        with open(filename, 'wb') as output:  # Overwrites any existing file.
            pickle.dump(self, output, pickle.HIGHEST_PROTOCOL)
            
if __name__ == '__main__':
    filename = 'SingleSoliton_256.pkl'
    # x = QuantumFlux(input_filename = filename)
    x = QuantumFlux(input_filename=filename)
    x.calculateParams()